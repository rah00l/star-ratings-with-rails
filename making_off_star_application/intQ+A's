* Compairesion of Postgreql and Mysql
-----------------------------------------------------------------------------------------------
			Postgreql			Mysql	
-----------------------------------------------------------------------------------------------
ANSI SQL compliance 	Closer to ANSI SQL standard 	Follows some of the ANSI SQL standards
Performance 		Slower 				Faster
Sub-selects 		Yes 				No
Transactions 		Yes 				Yes, however InnoDB table type must be used
Database replication 	Yes 				Yes
Foreign key support 	Yes 				No
Views 			Yes 				No
Stored procedures 	Yes 				No
Triggers 		Yes 				No
Unions 			Yes 				No
Full joins 		Yes 				No
Constraints 		Yes 				No
Windows support 	Yes 				Yes
Vacuum (cleanup) 	Yes 				No
ODBC 			Yes 				Yes
JDBC 			Yes 				Yes
Different table types 	No 				Yes


When to use MySQL:-
Why would you use MySQL over PostgreSQL? First, we need to consider the needs of the applications in terms of database requirements. If I want to create a Web application and performance is an issue, MySQL will be my choice because it’s fast and designed to work well with Web-based servers. However, if I want to create another application that demands transactions and foreign key references, PostgreSQL is the choice.


Let me suggest some reasons for using MySQL over PostgreSQL:

    MySQL is relatively faster than PostgreSQL.
    Database design will be simpler.
    You can create a basic Web-driven Web site.
    MySQL’s replication has been thoroughly tested.
    There’s no need for cleanups in MySQL (Vacuum).


When to use PostgreSQL:-
Not many Web developers use PostgreSQL because they feel that the additional features degrade performance.

For example, some of the features I use are foreign key references, triggers, and views. They allow me to hide the complexity of the database from the application, thus avoiding the creation of complicated SQL commands. I know many developers who prefer the rich functionality of PostgreSQL’s SQL commands. One of the most notable differences between MySQL and PostgreSQL is the fact that you can’t do nested subqueries of subselects in MySQL. PostgreSQL follows many of the SQL ANSI standards, thus allowing the creation of complex SQL commands.



Let me suggest some reasons for using PostgreSQL over MySQL:

    Complex database design
    Moving away from Oracle, Sybase, or MSSQL
    Complex rule sets (i.e., business rules)
    Use of procedural languages on the server
    Transactions
    Use of stored procedures
    Use of geographical data
    R-Trees (i.e., used on indexes)

************************************************************************

 Difference between HTTP and HTTPS: HTTPS = HTTP + SSL

1. URL begins with “http://" in case of HTTP while the URL begins with “https://” in case of HTTPS.
2. HTTP is unsecured while HTTPS is secured.
3. HTTP uses port 80 for communication while HTTPS uses port 443 for communication.
4. HTTP operates at Application Layer while HTTPS operates at Transport Layer.
5. No encryption is there in HTTP while HTTPS uses encryption.
6. No certificates required in HTTP while certificates required in HTTPS.

How HTTPS works?
For HTTPS connection, public key and signed certificates are required for the server. 
 When using an https connection, the server responds to the initial connection by offering a list of encryption methods it supports. In response, the client selects a connection method, and the client and server exchange certificates to authenticate their identities. After this is done, both parties exchange the encrypted information after ensuring that both are using the same key, and the connection is closed. In order to host https connections, a server must have a public key certificate, which embeds key information with a verification of the key owner's identity. Most certificates are verified by a third party so that clients are assured that the key is secure.
In other words, we can say, HTTPS works similar to HTTP but SSL adds some spice in it.



************************************************************************

Simple Object Access Protocol (SOAP) and REpresentational State Transfer (REST) :-
    SOAP and REST are protocols: a set of rules for requesting information from a server using a specific technique.




SOAP: -
    * Originally developed by Microsoft, SOAP really isn’t as simple as the acronym would suggest.
    * SOAP relies exclusively on XML to provide messaging services. 
    * Microsoft originally developed SOAP to take the place of older technologies that don’t work well on the Internet such as the Distributed Component          Object Model (DCOM) and Common Object Request Broker Architecture (CORBA). These technologies fail because they rely on binary messaging; the XML           messaging that SOAP employs works better over the Internet.
    * The XML used to make requests and receive responses in SOAP can become extremely complex. In some programming languages, you need to build those         requests manually, which becomes problematic because SOAP is intolerant of errors.
    * Part of the magic is the Web Services Description Language (WSDL). This is another file that’s associated with SOAP. It provides a definition of          how the Web service works, so that when you create a reference to it, the IDE can completely automate the process.
    * One of the most important SOAP features is built-in error handling. If there’s a problem with your request, the response contains error information           that you can use to fix the problem.




REST:-
    * REST is the newcomer to the block. It seeks to fix the problems with SOAP and provide a truly simple method of accessing Web services.
    * Many developers found SOAP cumbersome and hard to use. For example, working with SOAP in JavaScript means writing a ton of code to perform            extremely simple tasks because you must create the required XML structure absolutely every time.
    * REST provides a lighter weight alternative.
    * Instead of using XML to make a request, REST relies on a simple URL in many cases.
    * REST can use four different HTTP 1.1 verbs (GET, POST, PUT, and DELETE) to perform tasks.
    * Unlike SOAP, REST doesn’t have to use XML to provide the response. You can find REST-based Web services that output the data in Command Separated             Value (CSV), JavaScript Object Notation (JSON) and Really Simple Syndication (RSS). The point is that you can obtain the output you need in a           form that’s easy to parse within the language you need for your application.

SOAP is definitely the heavyweight choice for Web service access. It provides the following advantages when compared to REST:

    Language, platform, and transport independent (REST requires use of HTTP)
    Works well in distributed enterprise environments (REST assumes direct point-to-point communication)
    Standardized
    Provides significant pre-build extensibility in the form of the WS* standards
    Built-in error handling
    Automation when used with certain language products

REST is easier to use for the most part and is more flexible. It has the following advantages when compared to SOAP:

    No expensive tools require to interact with the Web service
    Smaller learning curve
    Efficient (SOAP uses XML for all messages, REST can use smaller message formats)
    Fast (no extensive processing required)
    Closer to other Web technologies in design philosophy.

******************************************************************************************************************************************************
Web Server and Application server:-

Most of the times these terms Web Server and Application server are used interchangeably.

Following are some of the key differences in features of Web Server and Application Server:

    Web Server is designed to serve HTTP Content. App Server can also serve HTTP Content but is not limited to just HTTP. It can be provided other protocol support such as RMI/RPC
    Web Server is mostly designed to serve static content, though most Web Servers have plugins to support scripting languages like Perl, PHP, ASP, JSP etc. through which these servers can generate dynamic HTTP content.
    Most of the application servers have Web Server as integral part of them, that means App Server can do whatever Web Server is capable of. Additionally App Server have components and features to support Application level services such as Connection Pooling, Object Pooling, Transaction Support, Messaging services etc.
    As web servers are well suited for static content and app servers for dynamic content, most of the production environments have web server acting as reverse proxy to app server. That means while servicing a page request, static contents (such as images/Static HTML) are served by web server that interprets the request. Using some kind of filtering technique (mostly extension of requested resource) web server identifies dynamic content request and transparently forwards to app server

Example of such configuration is Apache Tomcat HTTP Server and Oracle (formerly BEA) WebLogic Server. Apache Tomcat HTTP Server is Web Server and Oracle WebLogic is Application Server.

In some cases the servers are tightly integrated such as IIS and .NET Runtime. IIS is web server. When equipped with .NET runtime environment, IIS is capable of providing application services.

******************************************************************************************************************************************************


Differences between Procs and Lambdas: 
    * It is important to mention that they are both Proc objects.
        proc = Proc.new { puts "Hello world" }
        lam = lambda { puts "Hello World" }
        
        proc.class # returns 'Proc'
        lam.class

    ** Lambdas check the number of arguments, while procs do not

    1 lam = lambda { |x| puts x }    # creates a lambda that takes 1 argument
    2 lam.call(2)                    # prints out 2
    3 lam.call                       # ArgumentError: wrong number of arguments (0 for 1)
    4. lam.call(1,2,3)                # ArgumentError: wrong number of arguments (3 for 1)

    In contrast, procs don’t care if they are passed the wrong number of arguments.

    1 proc = Proc.new { |x| puts x } # creates a proc that takes 1 argument
    2 proc.call(2)                   # prints out 2
    3 proc.call                      # returns nil
    4 proc.call(1,2,3)               # prints out 1 and forgets about the extra arguments
    
    As shown above, procs don’t freak out and raise errors if they are passed the wrong number of arguments. If the proc requires an argument but no    argument is passed then the proc returns nil. If too many arguments are passed than it ignores the extra arguments. 

    ** Lambdas and procs treat the ‘return’ keyword differently 
       ‘return’ inside of a lambda triggers the code right outside of the lambda code 
        
        def lambda_test
          lam = lambda { return }
          lam.call
          puts "Hello world"
        end

        lambda_test                 # calling lambda_test prints 'Hello World'

       ‘return’ inside of a proc triggers the code outside of the method where the proc is being executed 

        def proc_test
          proc = Proc.new { return }
          proc.call
          puts "Hello world"
        end

        proc_test                 # calling proc_test prints nothing


******************************************************************************************************************************************************

The Asset Pipeline :-

    *** The first feature of the pipeline is to concatenate assets, which can reduce the number of requests that a browser makes to render a web page.          Web browsers are limited in the number of requests that they can make in parallel, so fewer requests can mean faster loading for your application.
        Sprockets concatenates all JavaScript files into one master .js file and all CSS files into one master .css file. 

    *** The second feature of the asset pipeline is asset minification or compression. For CSS files, this is done by removing whitespace and comments.             For JavaScript, more complex processes can be applied. You can choose from a set of built in options or specify your own.

    *** The third feature of the asset pipeline is it allows coding assets via a higher-level language, with precompilation down to the actual assets.          Supported languages include Sass for CSS, CoffeeScript for JavaScript, and ERB for both by default.


******************************************************************************************************************************************************
Ruby Keyword super :- 

A common use of inheritance is to have overridden methods in a subclass do something in addition to what the superclass method did, rather than something entirely different (like in previous examples). This allows us to re-use behaviour that exists in a superclass, then modify to suit the needs of the subclass.

Most object oriented languages offer a mechanism by which an overridden method can be called by the overriding method. Ruby uses the super keyword to make this happen. Using super will call the same method, but as defined in the superclass and give you the result.


class Animal
  def move
    "I can move"
  end
  def eat 
    "Can eat small fishes..!"
  end
end

class Bird < Animal
  def move
    super + " by flying"
  end
  def eat 
    super + "can eat big fishes..!"
  end
end

puts Animal.new.move
puts Bird.new.move
puts Bird.new.eat    

O/P =>

 stdout:

I can move
I can move by flying
Can eat small fishes..!can eat big fishes..!

******************************************************************************************************************************************************


jQuery differences between the bind and live functions:

In short: .bind() will only apply to the items you currently have selected in your jQuery object. .live() will apply to all current matching elements, as well as any you might add in the future.

The underlying difference between them is that live() makes use of event bubbling. That is, when you click on a button, that button might exist in a <p>, in a <div>, in a <body> element; so in effect, you're actually clicking on all of those elements at the same time.

live() works by attaching your event handler to the document, not to the element. When you click on that button, as illustrated before, the document receives the same click event. It then looks back up the line of elements targeted by the event and checks to see if any of them match your query.

The outcome of this is twofold: firstly, it means that you don't have to continue reapplying events to new elements, since they'll be implicitly added when the event happens. However, more importantly (depending on your situation), it means that your code is much much lighter! If you have 50 <img> tags on the page and you run this code:

$('img').click(function() { /* doSomething */ });

...then that function is copied into each of those elements. However, if you had this code:

$('img').live('click', function() { /* doSomething */ });

...then that function is stored only in one place (on the document), and is applied to whatever matches your query at event time.

Because of this bubbling behaviour though, not all events can be handled this way. As Ichiban noted, these supported events are click, dblclick mousedown, mouseup, mousemove, mouseover, mouseout, keydown, keypress, keyup.

******************************************************************************************************************************************************

Q- difference between collection routes and member routes in Rails

A member route will require an ID, because it acts on a member. A collection route doesn't because it acts on a collection of objects. Preview is an example of a member route, because it acts on (and displays) a single object. Search is an example of a collection route, because it acts on (and displays) a collection of objects.

******************************************************************************************************************************************************

Q - Preload, Eagerload, Includes and Joins. 

Preload loads the association data in a separate query. 

User.preload(:posts).to_a

# =>
SELECT "users".* FROM "users"
SELECT "posts".* FROM "posts"  WHERE "posts"."user_id" IN (1)

This is how includes loads data in the default case.

Since preload always generates two sql we can't use posts table in where condition. Following query will result in an error.


User.preload(:posts).where("posts.desc='ruby is awesome'")

# =>
SQLite3::SQLException: no such column: posts.desc: 
SELECT "users".* FROM "users"  WHERE (posts.desc='ruby is awesome')


----------------------------------------------------------------------------------
Includes :

*Q* User.includes(:posts).where('posts.desc = "ruby is awesome"').to_a

# =>
SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, "posts"."id" AS t1_r0, 
       "posts"."title" AS t1_r1, 
       "posts"."user_id" AS t1_r2, "posts"."desc" AS t1_r3 
FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id" 
WHERE (posts.desc = "ruby is awesome")

 As you can see includes switches from using two separate queries to creating a single LEFT OUTER JOIN to get the data. And it also applied the supplied condition.

----------------------------------------------------------------------------------

Eager loading loads all association in a single query using LEFT OUTER JOIN.

User.eager_load(:posts).to_a

# =>
SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, "posts"."id" AS t1_r0, 
       "posts"."title" AS t1_r1, "posts"."user_id" AS t1_r2, "posts"."desc" AS t1_r3 
FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"


----------------------------------------------------------------------------------

Joins brings association data using inner join. 

User.joins(:posts)

# =>
SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id"


In the above case no posts data is selected. Above query can also produce duplicate result. To see it let's create some sample data.

def self.setup
  User.delete_all
  Post.delete_all

  u = User.create name: 'Neeraj'
  u.posts.create! title: 'ruby', desc: 'ruby is awesome'
  u.posts.create! title: 'rails', desc: 'rails is awesome'
  u.posts.create! title: 'JavaScript', desc: 'JavaScript is awesome'

  u = User.create name: 'Neil'
  u.posts.create! title: 'JavaScript', desc: 'Javascript is awesome'

  u = User.create name: 'Trisha'
end

With the above sample data if we execute User.joins(:posts) then this is the result we get

#<User id: 9, name: "Neeraj">
#<User id: 9, name: "Neeraj">
#<User id: 9, name: "Neeraj">
#<User id: 10, name: "Neil">

We can avoid the duplication by using distinct .

User.joins(:posts).select('distinct users.*').to_a

Also if we want to make use of attributes from posts table then we need to select them.

records = User.joins(:posts).select('distinct users.*, posts.title as posts_title').to_a
records.each do |user|
  puts user.name
  puts user.posts_title
end

Note that using joins means if you use user.posts then another query will be performed.

******************************************************************************************************************************************************

Class and Instance Methods in Ruby

One Line Summary

Class methods are methods that are called on a class and instance methods are methods that are called on an instance of a class. Here is a quick example and then we’ll go into a bit more detail.

class Foo
  def self.bar
    puts 'class method'
  end
  
  def baz
    puts 'instance method'
  end
end

Foo.bar # => "class method"
Foo.baz # => NoMethodError: undefined method ‘baz’ for Foo:Class

Foo.new.baz # => instance method
Foo.new.bar # => NoMethodError: undefined method ‘bar’ for #<Foo:0x1e820>

See the difference? bar is a class method, so calling bar on the Foo class works fine. baz is an instance method, so calling baz on the Foo class raises a NoMethodError. Then, on the next couple lines, we call both methods on an instance of Foo (Foo.new).


So when would you use a class method? Class methods are for anything that does not deal with an individual instance of a class. ActiveRecord::Base#find is one example. If you look in ActiveRecord::Base, you’ll see something like this:

module ActiveRecord
  class Base
    # some stuff
    class << self
      def find(...)
        # blah
      end
    end
  end
end


The key difference is instance methods only work with an instance and thus you have to create a new instance to use them (Foo.new).

e.g. destroy is an instance method, save and update_attributes

******************************************************************************************************************************************************

Include vs Extend in Ruby

The difference between include and extend in regards to modules. Include is for adding methods to an instance of a class and extend is for adding class methods. Let’s take a look at a small example.


module Foo
  def foo
    puts 'heyyyyoooo!'
  end
end

class Bar
  include Foo
end

Bar.new.foo # heyyyyoooo!
Bar.foo # NoMethodError: undefined method ‘foo’ for Bar:Class

class Baz
  extend Foo
end

Baz.foo # heyyyyoooo!
Baz.new.foo # NoMethodError: undefined method ‘foo’ for #<Baz:0x1e708>

As you can see, include makes the foo method available to an instance of a class and extend makes the foo method available to the class itself.


******************************************************************************************************************************************************

Require vs Load :

require searches for the library in all the defined search paths and also appends .rb or .so to the file name you enter.With load you need to add the full name of the library.

If you require the same file twice, it will be loaded and evaluated only once. load, on the other hand, loads and evaluates the file every time.

e.g.
Here is the code from 'boot.rb'
require 'rubygems'

# Set up gems listed in the Gemfile.
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])


load(File.dirname(__FILE__) + "/schema.rb")


******************************************************************************************************************************************************


Rails 4 :

Datatype:

datatypes (for postgress database) : hstore , (array: true)

ActiveRecord :

ActiveRecord - (return active_relation object)

ActiveRecord-Mothods - not, order method can pass hash 

dynamic finder methods has been deprecated but find_by_name is still there.

ActiveModel -> can include ActiveModel::Model and can use any ruby class with all ActiveRecord features like validations and all without saving data into database;

Yes it is also available previously but not easier need to include library files ...

Not need to remove index.html from public folder. it's now dynamicaly generated.

turbolink is auto enabled (In order to make Single Page Application)-instead of reloading the entire page only part of page has been used to make turbolink requests.


Controller : 

before_filter / now got know as before_action ...

New patch request introduced which would work similler to put.
Can use update instead of update_attribut/s interchangably. 

Introduced strong parameters not need to add attr_atributes ..


******************************************************************************************************************************************************

Difference between attr_accessor and attr_accessible:

This is a very good question. I was as well very confused with all of this and I finaly undersood the point.

Many people on this thread and on google explain very well that :

attr_accessible specifies a whitelist of attributes that are allowed to be updated in bulk (all the attributes of an object model together at the same time) This is mainly (and only) to protect your application from "Mass assignement" pirate exploit. This is explained here on the official Rails doc : Mass Assignement

attr_accessor is a ruby code to (quickly) create setter and getter in a Class. That's all.


attr_accessor is a ruby method that makes a getter and a setter. attr_accessible is a Rails method that allows you to pass in values to a mass assignment: new(attrs) or update_attributes(attrs). 



The attr_protected method takes a list of attributes that will not be accessible for mass-assignment.

The attr_accessible method it is the exact opposite of attr_protected, because it takes a list of attributes that will be accessible. 


attr_accessor as a ruby method that is the combination of attr_reader and attr_writer.

NOTE! Don’t use attr_accessor for database attributes – Rails creates those accessors for you.

attr_accessor is used when you do not have a column in your database, but still want to show a field in your forms. This field is a “virtual attribute” in a Rails model.

virtual attribute – an attribute not corresponding to a column in the database.


Views :

collection_check_boxes  (to atchive many-to-many kind of relation with check boxes)

date_field (like html 5 date field which populate calender)

cash digest and russian doll

routes:

concerns (useful while concern with complicated routes/api's call url/ polymorphic assocation routes)

instead of match route can use what type of http request it is for.

Can use constrains with help of that can specify protocol then route will generate likewise.

Test:

where test directory is strucured differently




