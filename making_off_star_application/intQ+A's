
Why RUBY :-
------------

1. It’s easy to Learn
2. Save time by writing more with less.
3. Write web apps quickly and easily.
4. The community will help you.
5. It’s easy on the pocketbook.
6. Ruby can be customized.
7. It’s portable.
8. You can make your own Domain-Specific language.
9. Learning Ruby will get you more work.


Ruby has many cool features which attract developers, such as 

* the ability to create classes at runtime, (define method- metaprograming)
* alter behavior of any particular object, 
* monitor the number of classes in memory using ObjectSpace - ?, 
* and an extensive list of test-suites. 


- Ruby is considered a higher level programming language than C++. 
- A high-level language features strong abstractions from computer details. 
- Whereas low-level languages are closer to machine details (like memory addresses or CPU registers), high-level languages are closer to a naturally spoken language.

************************************************************************************************************************************************

Disadvantages of Ruby Programming:
----------------------------------

1. Less Communities and Support  --- compare to other language.
2. Slow Processing --- compare to other language.
            Ruby is often slower to run and requires more memory than Java, though this gap has closed somewhat with the release of Ruby 1.9.
3. New Language

************************************************************************************************************************************************

Ruby Object Oriented Programming Language:
-------------------------------------------

A class definition starts with the keyword class followed by the class name and is delimited with an end. For example, we defined the Box class using the keyword class as follows:

class Box
   code
end

We declare objects of a class using new keyword. 

box1 = Box.new
box2 = Box.new


The initialize method is a standard Ruby class method and works almost same way as constructor works in other object oriented programming languages. The initialize method is useful when you want to initialize some class variables at the time of object creation.

************************************************************************************************************************************************

* Compairesion of Postgreql and Mysql :-

-----------------------------------------------------------------------------------------------
			Postgreql			Mysql	
-----------------------------------------------------------------------------------------------
ANSI SQL compliance 	Closer to ANSI SQL standard 	Follows some of the ANSI SQL standards
Performance 		Slower 				Faster
Sub-selects 		Yes 				No
Transactions 		Yes 				Yes, however InnoDB table type must be used
Database replication 	Yes 				Yes
Foreign key support 	Yes 				No
Views 			Yes 				No
Stored procedures 	Yes 				No
Triggers 		Yes 				No
Unions 			Yes 				No
Full joins 		Yes 				No
Constraints 		Yes 				No
Windows support 	Yes 				Yes
Vacuum (cleanup) 	Yes 				No
ODBC 			Yes 				Yes
JDBC 			Yes 				Yes
Different table types 	No 				Yes


When to use MySQL:-
Why would you use MySQL over PostgreSQL? First, we need to consider the needs of the applications in terms of database requirements. If I want to create a Web application and performance is an issue, MySQL will be my choice because it’s fast and designed to work well with Web-based servers. However, if I want to create another application that demands transactions and foreign key references, PostgreSQL is the choice.


Let me suggest some reasons for using MySQL over PostgreSQL:

    MySQL is relatively faster than PostgreSQL.
    Database design will be simpler.
    You can create a basic Web-driven Web site.
    MySQL’s replication has been thoroughly tested.
    There’s no need for cleanups in MySQL (Vacuum).


When to use PostgreSQL:-
Not many Web developers use PostgreSQL because they feel that the additional features degrade performance.

For example, some of the features I use are foreign key references, triggers, and views. They allow me to hide the complexity of the database from the application, thus avoiding the creation of complicated SQL commands. I know many developers who prefer the rich functionality of PostgreSQL’s SQL commands. One of the most notable differences between MySQL and PostgreSQL is the fact that you can’t do nested subqueries of subselects in MySQL. PostgreSQL follows many of the SQL ANSI standards, thus allowing the creation of complex SQL commands.



Let me suggest some reasons for using PostgreSQL over MySQL:

    Complex database design
    Moving away from Oracle, Sybase, or MSSQL
    Complex rule sets (i.e., business rules)
    Use of procedural languages on the server
    Transactions
    Use of stored procedures
    Use of geographical data
    R-Trees (i.e., used on indexes)

******************************************************************************************************************************************************

SQL vs NoSQL: High-Level Differences

    * SQL databases are primarily called as Relational Databases (RDBMS); whereas NoSQL database are primarily called as non-relational or distributed database.
    
    * SQL databases are table based databases whereas NoSQL databases are document based, key-value pairs, graph databases or wide-column stores. 

    * This means that SQL databases represent data in form of tables which consists of n number of rows of data whereas NoSQL databases are the collection of key-value pair, documents, graph databases or wide-column stores which do not have standard schema definitions which it needs to adhered to.

    * SQL databases have predefined schema whereas NoSQL databases have dynamic schema for unstructured data.

    * SQL databases are vertically scalable whereas the NoSQL databases are horizontally scalable. SQL databases are scaled by increasing the horse-power of the hardware. NoSQL databases are scaled by increasing the databases servers in the pool of resources to reduce the load.

    * SQL databases uses SQL ( structured query language ) for defining and manipulating the data, which is very powerful. In NoSQL database, queries are focused on collection of documents. Sometimes it is also called as UnQL (Unstructured Query Language). The syntax of using UnQL varies from database to database.

    * SQL database examples:- MySql, Oracle, Sqlite, Postgres and MS-SQL. 
      NoSQL database examples: MongoDB, BigTable, Redis, RavenDb, Cassandra, Hbase, Neo4j and CouchDb.

    * For complex queries:- SQL databases are good fit for the complex query intensive environment whereas NoSQL databases are not good fit for complex queries. On a high-level, NoSQL don’t have standard interfaces to perform complex queries, and the queries themselves in NoSQL are not as powerful as SQL query language.

    * For the type of data to be stored: SQL databases are not best fit for hierarchical data storage. But, NoSQL database fits better for the hierarchical data storage as it follows the key-value pair way of storing data similar to JSON data. NoSQL database are highly preferred for large data set (i.e for big data). Hbase is an example for this purpose.
    
    * For scalability: In most typical situations, SQL databases are vertically scalable. You can manage increasing load by increasing the CPU, RAM, SSD, etc, on a single server. On the other hand, NoSQL databases are horizontally scalable. You can just add few more servers easily in your NoSQL database infrastructure to handle the large traffic.
    
    * For high transactional based application: SQL databases are best fit for heavy duty transactional type applications, as it is more stable and promises the atomicity as well as integrity of the data. While you can use NoSQL for transactions purpose, it is still not comparable and sable enough in high load and for complex transactional applications.

    * For support: Excellent support are available for all SQL database from their vendors. There are also lot of independent consultations who can help you with SQL database for a very large scale deployments. For some NoSQL database you still have to rely on community support, and only limited outside experts are available for you to setup and deploy your large scale NoSQL deployments.

    * For properties: SQL databases emphasizes on ACID properties ( Atomicity, Consistency, Isolation and Durability) whereas the NoSQL database follows the Brewers CAP theorem ( Consistency, Availability and Partition tolerance )
    
    * For DB types: On a high-level, we can classify SQL databases as either open-source or close-sourced from commercial vendors. NoSQL databases can be classified on the basis of way of storing data as graph databases, key-value store databases, document store databases, column store database and XML databases.


************************************************************************************************************************************************

Ruby ORM List :
-------------------

1.    ActiveRecord, part of Ruby on Rails, open source
2.    Sequel
3.    Datamapper (inactive)
4.    iBATIS (inactive)


************************************************************************************************************************************************


 Difference between HTTP and HTTPS: HTTPS = HTTP + SSL

1. URL begins with “http://" in case of HTTP while the URL begins with “https://” in case of HTTPS.
2. HTTP is unsecured while HTTPS is secured.
3. HTTP uses port 80 for communication while HTTPS uses port 443 for communication.
4. HTTP operates at Application Layer while HTTPS operates at Transport Layer.
5. No encryption is there in HTTP while HTTPS uses encryption.
6. No certificates required in HTTP while certificates required in HTTPS.

How HTTPS works?
For HTTPS connection, public key and signed certificates are required for the server. 
 When using an https connection, the server responds to the initial connection by offering a list of encryption methods it supports. In response, the client selects a connection method, and the client and server exchange certificates to authenticate their identities. After this is done, both parties exchange the encrypted information after ensuring that both are using the same key, and the connection is closed. In order to host https connections, a server must have a public key certificate, which embeds key information with a verification of the key owner's identity. Most certificates are verified by a third party so that clients are assured that the key is secure.
In other words, we can say, HTTPS works similar to HTTP but SSL adds some spice in it.

************************************************************************************************************************************************

Simple Object Access Protocol (SOAP) and REpresentational State Transfer (REST) :-
    SOAP and REST are protocols: a set of rules for requesting information from a server using a specific technique.

SOAP: -
    * Originally developed by Microsoft, SOAP really isn’t as simple as the acronym would suggest.
    * SOAP relies exclusively on XML to provide messaging services. 
    * Microsoft originally developed SOAP to take the place of older technologies that don’t work well on the Internet such as the Distributed Component          Object Model (DCOM) and Common Object Request Broker Architecture (CORBA). These technologies fail because they rely on binary messaging; the XML           messaging that SOAP employs works better over the Internet.
    * The XML used to make requests and receive responses in SOAP can become extremely complex. In some programming languages, you need to build those         requests manually, which becomes problematic because SOAP is intolerant of errors.
    * Part of the magic is the Web Services Description Language (WSDL). This is another file that’s associated with SOAP. It provides a definition of          how the Web service works, so that when you create a reference to it, the IDE can completely automate the process.
    * One of the most important SOAP features is built-in error handling. If there’s a problem with your request, the response contains error information           that you can use to fix the problem.


REST:-
    * REST is the newcomer to the block. It seeks to fix the problems with SOAP and provide a truly simple method of accessing Web services.
    * Many developers found SOAP cumbersome and hard to use. For example, working with SOAP in JavaScript means writing a ton of code to perform            extremely simple tasks because you must create the required XML structure absolutely every time.
    * REST provides a lighter weight alternative.
    * Instead of using XML to make a request, REST relies on a simple URL in many cases.
    * REST can use four different HTTP 1.1 verbs (GET, POST, PUT, and DELETE) to perform tasks.
    * Unlike SOAP, REST doesn’t have to use XML to provide the response. You can find REST-based Web services that output the data in Command Separated             Value (CSV), JavaScript Object Notation (JSON) and Really Simple Syndication (RSS). The point is that you can obtain the output you need in a           form that’s easy to parse within the language you need for your application.

SOAP is definitely the heavyweight choice for Web service access. It provides the following advantages when compared to REST:

    Language, platform, and transport independent (REST requires use of HTTP)
    Works well in distributed enterprise environments (REST assumes direct point-to-point communication)
    Standardized
    Provides significant pre-build extensibility in the form of the WS* standards
    Built-in error handling
    Automation when used with certain language products

REST is easier to use for the most part and is more flexible. It has the following advantages when compared to SOAP:

    No expensive tools require to interact with the Web service
    Smaller learning curve
    Efficient (SOAP uses XML for all messages, REST can use smaller message formats)
    Fast (no extensive processing required)
    Closer to other Web technologies in design philosophy.

******************************************************************************************************************************************************

Web Server and Application server:-
------------------------------------

Most of the times these terms Web Server and Application server are used interchangeably.

Following are some of the key differences in features of Web Server and Application Server:

    Web Server is designed to serve HTTP Content. App Server can also serve HTTP Content but is not limited to just HTTP. It can be provided other protocol support such as RMI/RPC
    Web Server is mostly designed to serve static content, though most Web Servers have plugins to support scripting languages like Perl, PHP, ASP, JSP etc. through which these servers can generate dynamic HTTP content.

    Most of the application servers have Web Server as integral part of them, that means App Server can do whatever Web Server is capable of. 

    Additionally App Server have components and features to support Application level services such as 
    * Connection Pooling, 
    * Object Pooling, 
    * Transaction Support, 
    * Messaging services etc.

    As web servers are well suited for static content and app servers for dynamic content, most of the production environments have web server acting as reverse proxy to app server. 

    That means while servicing a page request, static contents (such as images/Static HTML) are served by web server that interprets the request. Using some kind of filtering technique (mostly extension of requested resource) web server identifies dynamic content request and transparently forwards to app server

Example of such configuration is Apache Tomcat HTTP Server and Oracle (formerly BEA) WebLogic Server. Apache Tomcat HTTP Server is Web Server and Oracle WebLogic is Application Server.

In some cases the servers are tightly integrated such as IIS and .NET Runtime. IIS is web server. When equipped with .NET runtime environment, IIS is capable of providing application services.

******************************************************************************************************************************************************

Differences between Procs and Lambdas: 
    * It is important to mention that they are both Proc objects.
        proc = Proc.new { puts "Hello world" }
        lam = lambda { puts "Hello World" }
        
        proc.class # returns 'Proc'
        lam.class

    ** Lambdas check the number of arguments, while procs do not

    1 lam = lambda { |x| puts x }    # creates a lambda that takes 1 argument
    2 lam.call(2)                    # prints out 2
    3 lam.call                       # ArgumentError: wrong number of arguments (0 for 1)
    4. lam.call(1,2,3)                # ArgumentError: wrong number of arguments (3 for 1)

    In contrast, procs don’t care if they are passed the wrong number of arguments.

    1 proc = Proc.new { |x| puts x } # creates a proc that takes 1 argument
    2 proc.call(2)                   # prints out 2
    3 proc.call                      # returns nil
    4 proc.call(1,2,3)               # prints out 1 and forgets about the extra arguments
    
    As shown above, procs don’t freak out and raise errors if they are passed the wrong number of arguments. If the proc requires an argument but no    argument is passed then the proc returns nil. If too many arguments are passed than it ignores the extra arguments. 

    ** Lambdas and procs treat the ‘return’ keyword differently 
       ‘return’ inside of a lambda triggers the code right outside of the lambda code 
        
        def lambda_test
          lam = lambda { return }
          lam.call
          puts "Hello world"
        end

        lambda_test                 # calling lambda_test prints 'Hello World'

       ‘return’ inside of a proc triggers the code outside of the method where the proc is being executed 

        def proc_test
          proc = Proc.new { return }
          proc.call
          puts "Hello world"
        end

        proc_test                 # calling proc_test prints nothing

******************************************************************************************************************************************************

Q- difference between collection routes and member routes in Rails:-

A member route will require an ID, because it acts on a member. A collection route doesn't because it acts on a collection of objects. Preview is an example of a member route, because it acts on (and displays) a single object. Search is an example of a collection route, because it acts on (and displays) a collection of objects.


******************************************************************************************************************************************************

The Asset Pipeline :-
---------------------

    *** The first feature of the pipeline is to concatenate assets, which can reduce the number of requests that a browser makes to render a web page.          Web browsers are limited in the number of requests that they can make in parallel, so fewer requests can mean faster loading for your application.
        Sprockets concatenates all JavaScript files into one master .js file and all CSS files into one master .css file. 

    *** The second feature of the asset pipeline is asset minification or compression. For CSS files, this is done by removing whitespace and comments.             For JavaScript, more complex processes can be applied. You can choose from a set of built in options or specify your own.

    *** The third feature of the asset pipeline is it allows coding assets via a higher-level language, with precompilation down to the actual assets.          Supported languages include Sass for CSS, CoffeeScript for JavaScript, and ERB for both by default.

******************************************************************************************************************************************************

Single Table Inheritance: vs Polymorphic Association:-
******************************************************

This is a common to have join between two tables based on condition. suppose we have table in database called comments and we can have comments on different thing like a video, profile or picture. So keeping DRY (Don’t repeat yourself) principle in mind while designing your database. You may want to have relationship between single comments table and videos or profiles table.

At database level you should have two fields in table one field (i.e. type) that identifies the type of comment whether it is a comment on video or it’s a comment on profile, and another field (i.e source_id) that contains id of the video or profile that comment was on.

In Ruby on Rails currently there are two ways to define this kind of association between your activerecord models:

Single Table Inheritance:

Here you ‘ll create a single table of comments and Comment AR class, there would be two additional classes ProfileComment and VideoComment inheriting from same Comment AR class. Instead of having association between Profile and Comment model there would be association between Profile and ProfileComment subclass. Same will be the case with Video model and VideoComment subclass.

If we take a look at comment table we ‘ll see that class name for each record will be automatically stored in type field. The reference to associated table would be in source_id field.


class Comment < ActiveRecord::Base
end
class VideoComment < Comment
belongs_to :video, :foreign_key => "source_id"
end
class ProfileComment < Comment
belongs_to :profile, :foreign_key => "source_id"
end

Polymorphic Association:

Since Rails 1.1 there is a simpler way to create this kind of relationship called polymorphic association. In case of polymorphic association you ‘ll have two fields called commentable_type and commentable_id, instead of type and source_id. The commentable_type field will store name of class which that instance relates to and commentable_id saves the reference to instance of that class. The relations will be created like this:


class Comment < ActiveRecord::Base
belongs_to :commentable, :polymorphic => true
end
class Video < ActiveRecord::Base
has_many :comments, :as => :commentable
end
class Profile < ActiveRecord::Base
has_many :comments, :as => :commentable
end

Pros and Cons:

    The STI approach offers more flexibilty by allowing you to have additional fields that only have value in case of one sub class. For access from other sub class can be disallowed be overridden accessors.
    The STI requires you to create a seperate class to implement a relation between two models, resulting in more classses. which is not case with polymorphic association
    The STI results in more code.It is confusing to some programmers to understand relation between STI classes
    The polymorphic association is very easy to implement.

******************************************************************************************************************************************************


How Rails Handle Sessions ?

Cookies + Sessions = ♥

Rails uses a CookieStore to handle sessions. What it means is that all the informations needed to identify a user's session is sent to the client and nothing is stored on the server. When a user sends a request, the session's cookie is processed and validated so rails, warden, devise, etc. can figure out who you are and instantiate the correct user from the database.

Like I said earlier, cookies are how server can remember who you are from one request to another. Everytime you send a request to a server, you send every cookie you have for that domain. Nothing new here. A session cookie is signed and encrypted (encryption is new in Rails 4) then sent to the browser. That cookie is actually an hash that would look like this if you run something like Warden and Devise:


cookie = {
  "session_id": "Value",
  "_csrf_token": "token",
  "user_id": "1"
}

Additional Information:

Encryption & Signature:

From the hash above, the cookie will become an encrypted and signed string that will then be sent to the client's browser in a Base64 format. Encryption is done with ActiveSupport::MessageEncryptor and the signature is done with ActiveSupport::MessageVerifier.

Those are the two gatekeepers for your application, if they are compromised, someone could log in as anyone. This is why Ruby on rails' guide specifies to use strong secrets for your session keys.




******************************************************************************************************************************************************
method_missing :
----------------

http://code.tutsplus.com/tutorials/ruby-for-newbies-missing-methods--net-20924

Let’s say your working with a Ruby object. And let’s also say that you aren’t entirely familiar with this object. And let’s also say that you call a method that doesn’t exist on the object.
    
o = <span class="skimlinks-unlinked">Object.new</span>
o.some_method
# NoMethodError: undefined method `some_method' for #<Object:0x00000100939828>

This is less than desirable, so Ruby has an awesome way of allowing us to rescue ourselves from this. Check this out:

    
class OurClass
  def method_missing (method_name)
    puts "there's no method called '#{method_name}'"
  end
end
 
o = <span class="skimlinks-unlinked">OurClass.new</span>
o.some_method
# => there's no method called 'some_method'

We can create a method called method_missing in our class. If the object we’re calling the method on doesn’t have the method (and doesn’t inherit the method from another class or module), Ruby will give us one more chance to do something useful: if the class has a method_missing method, we’ll hand the information about the method cal to method_missing and let it sort the mess out.

Well, that’s great; we’re no longer getting an error message.



******************************************************************************************************************************************************
Model Associations

    Explain the difference between a has_one and belongs_to association:

        has_one: Indicates a direct 1:1 relationship between objects where each instance of a model contains one instance of another model.

                A product has_one provider, a customer has_one order.

RoR_Q&A_has_one

A has_one association schematic, from Rubyonrails.org

    belongs_to: Represents the inverse of a has_one (or has_many) association.

        ex) An order belongs_to  a customer.

RoR_Q&A_belongs_to

A belongs_to association schematic, from Rubyonrails.org

        A good way to remember this is that if a table has foreign keys, its model should have a belongs_to association.

        Be able to explain the difference and describe an example of how you would assign these associations to two related models.

    
    Explain a polymorphic association:-
    -----------------------------------------

        Polymorphic associations allow a model to belong to more than one other model through a single association.

            A polymorphic association schematic, from Rubyonrails.org

        Model structures of a polymorphic association, in Ruby code, from Ruybonrails.org

        Here, the class Picture belongs_to both Employee and Product, but does so through a single association rather than through multiple.

        Be sure to know an appropriate situation to create a polymorphic association, such as creating a comment model associated with multiple other models (articles, photos, etc.). The advantage of using polymorphism here is that it allows you to create a single comment model, rather than separate models for each one (PhotoComment model, ArticleComment model, etc.)


******************************************************************************************************************************************************


What is the difference between includes and joins?

The most important concept to understand when using includes and joins is they both have their optimal use cases.

    " Includes uses eager loading whereas joins uses lazy loading "

Includes -

With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.

In other words, when querying a table for data with an associated table, both tables are loaded into memory which in turn reduce the amount of database queries required to retrieve any associated data.

e.g. 

Company.includes(:persons).where(:persons => { active: true } ).all
 
@companies.each do |company|
     company.person.name
end

When iterating through each of the companies and displaying the persons name, we would normally have to retrieve the persons name with a separate database query each time. However, when using the includes method, it has already eagerly loaded the associated person table, so this block only required a single query. Awesome, right?!

So what happens if I want to retrieve all companies with an active associated Person record, but I don’t want to display any data from the Person table? It’s starting to seem a tad overkill loading the associated table…well that’s where the joins method starts to shine!


e.g.

Company.joins(:persons).where(:persons => { active: true } ).all
 
 
@companies.each do |company|
     company.name
end

Visually the only difference is replacing the includes method call with joins, however under the hood there is a lot more going on. The joins method lazy loads the database query by utilising the associated table, but only loading the Company table into memory as the associated Person table is not required.Therefore we are not loading redundant data into memory needlessly; although if we wanted to use the Person table data later on from the same array variable, it would require further database queries.

Recently I fell victim to not using the awesome power behind the includes method in my Trado codebase. I noticed a severe performance leak when monitoring the database queries in my local instance server logs, which is a habit I would advise starting.

******************************************************************************************************************************************************

Duck typing :

    calling any method on any object, regardless of its class.


    When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. Instead of specifying types formally, duck typing practices rely on documentation, clear code, and testing to ensure correct use.

******************************************************************************************************************************************************


Ruby Keyword super :- 
----------------------

A common use of inheritance is to have overridden methods in a subclass do something in addition to what the superclass method did, rather than something entirely different (like in previous examples). This allows us to re-use behaviour that exists in a superclass, then modify to suit the needs of the subclass.

Most object oriented languages offer a mechanism by which an overridden method can be called by the overriding method. Ruby uses the super keyword to make this happen. Using super will call the same method, but as defined in the superclass and give you the result.


class Animal
  def move
    "I can move"
  end
  def eat 
    "Can eat small fishes..!"
  end
end

class Bird < Animal
  def move
    super + " by flying"
  end
  def eat 
    super + "can eat big fishes..!"
  end
end

puts Animal.new.move
puts Bird.new.move
puts Bird.new.eat    

O/P =>

 stdout:

I can move
I can move by flying
Can eat small fishes..!can eat big fishes..!

******************************************************************************************************************************************************


Thread -  
--------
  
  In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by an operating system scheduler. A thread is a light-weight process.

* Threads that belong to the same process share that process’s resources. This is why it is more economical to have threads in some cases. 

* Every feature comes with a price. Threads are good, but if you are writing multithreaded application code then you should be aware of handling race conditions. What is a race condition?



    Race conditions arise in software when separate computer processes or threads of execution depend on some shared state. Operations upon shared states are critical sections that must be mutually exclusive. Failure to obey this rule opens up the possibility of corrupting the shared state.


Mutual Exclusion - To fix race conditions, we have to control the program so that when one thread is doing work another should wait unitl the working thread finishes. This is called Mutual Exclusion and we use this concept to remove race conditions in our programs.

This is because of mutex.synchronize. One and only one thread can access the block wrapped in mutex.synchronize at any time. Other threads have to wait until the current thread that is processing completes. 

******************************************************************************************************************************************************

Interfaces in ruby:
---------------------

Interfaces are usually introduced to static typed OO languages in order to make up for lack of multiple inheritance. In other words, they are more of a necessary evil than something useful per se.

Ruby, on the other hand:

    Is dynamically typed language with "duck typing", so if you want to call method foo on two objects, they don't need to neither inherit same ancestor class, nor implement the same interface.
    Supports multiple inheritance through concept of mixins, again no need for interfaces here.

******************************************************************************************************************************************************


Include vs Extend in Ruby:
----------------------------

The difference between include and extend in regards to modules. Include is for adding methods to an instance of a class and extend is for adding class methods. Let’s take a look at a small example.


module Foo
  def foo
    puts 'heyyyyoooo!'
  end
end

class Bar
  include Foo
end

Bar.new.foo # heyyyyoooo!
Bar.foo # NoMethodError: undefined method ‘foo’ for Bar:Class

class Baz
  extend Foo
end

Baz.foo # heyyyyoooo!
Baz.new.foo # NoMethodError: undefined method ‘foo’ for #<Baz:0x1e708>

As you can see, include makes the foo method available to an instance of a class and extend makes the foo method available to the class itself.


******************************************************************************************************************************************************

Require vs Load :
-------------------

require searches for the library in all the defined search paths and also appends .rb or .so to the file name you enter.With load you need to add the full name of the library.

If you require the same file twice, it will be loaded and evaluated only once. load, on the other hand, loads and evaluates the file every time.

e.g.
Here is the code from 'boot.rb'
require 'rubygems'

# Set up gems listed in the Gemfile.
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])


load(File.dirname(__FILE__) + "/schema.rb")


******************************************************************************************************************************************************

Class and Instance Methods in Ruby:
------------------------------------

One Line Summary

Class methods are methods that are called on a class and instance methods are methods that are called on an instance of a class. Here is a quick example and then we’ll go into a bit more detail.

class Foo
  def self.bar
    puts 'class method'
  end
  
  def baz
    puts 'instance method'
  end
end

Foo.bar # => "class method"
Foo.baz # => NoMethodError: undefined method ‘baz’ for Foo:Class

Foo.new.baz # => instance method
Foo.new.bar # => NoMethodError: undefined method ‘bar’ for #<Foo:0x1e820>

See the difference? bar is a class method, so calling bar on the Foo class works fine. baz is an instance method, so calling baz on the Foo class raises a NoMethodError. Then, on the next couple lines, we call both methods on an instance of Foo (Foo.new).


So when would you use a class method? Class methods are for anything that does not deal with an individual instance of a class. ActiveRecord::Base#find is one example. If you look in ActiveRecord::Base, you’ll see something like this:

module ActiveRecord
  class Base
    # some stuff
    class << self
      def find(...)
        # blah
      end
    end
  end
end


The key difference is instance methods only work with an instance and thus you have to create a new instance to use them (Foo.new).

e.g. destroy is an instance method, save and update_attributes

******************************************************************************************************************************************************


******************************************************************************************************************************************************

Rails 2 vs Rails 3 :
--------------------

1. Unobtrusive JavaScript - introduction of Unobtrusive JavaScript (UJS) to all of its JavaScript helper functions. *** In previous versions of Rails, JavaScript was generated inline with HTML, causing ugly and somewhat brittle code. ***

    Rails 3 replaces all of the inline JavaScript with a couple of HTML5 attributes. All of the JavaScript event handlers to handle the actual confirmation box and deletion are stored in one central JavaScript file that is included with every rails project.

2. Improved Security -XSS protection is now enabled by default. Rails 2 supported   XSS protection through the use of the h method.    

    The h method would escape html and JavaScript to ensure that no malicious client-side code was executed.

3. New Query Engine -
    Rails 3 includes a cool new query engine that makes it easier to get back the data you want and gives you more flexibilitiy in your controller code.

    In Rails 3, each of the passed in parameters has its own method, which can be chained together to get the same results.

    The query is not actually executed until the data is needed (lazy loading); so these methods can even be used across multiple statements.   

4. Easier Email -The ActionMailer module has been rewritten to make it a lot easier for your application to send email in Rails 3.

5. Dependency Management - Rails 3 adds the Bundler gem to help manage your dependencies. Using Bundler in Rails 3 is extremely simple; add a line for each gem you require in your Gemfile, a file included in the root of each of your applications.

******************************************************************************************************************************************************


Rails 4 :

* Datatype:
  ----------

datatypes (for postgress database) : hstore , (array: true)

* ActiveRecord :
  ---------------

* ActiveRecord - (return active_relation object)

    Methods-
    not, order method can pass hash 

dynamic finder methods has been deprecated but find_by_name is still there.

ActiveModel -> can include ActiveModel::Model and can use any ruby class with all ActiveRecord features like validations and all without saving data into database;

Yes it is also available previously but not easier need to include library files ...

* Not need to remove index.html from public folder. it's now dynamicaly generated.

* turbolink is auto enabled (In order to make Single Page Application)-instead of    reloading the entire page only part of page has been used to make turbolink requests.


Controller : 
------------
before_filter / now got know as before_action ...

Model :
--------
New patch request introduced which would work similler to put.
Can use update instead of update_attribut/s interchangably. 

Introduced strong parameters not need to add attr_atributes ..

Views :
------
collection_check_boxes  (to atchive many-to-many kind of relation with check boxes)

date_field (like html 5 date field which populate calender)

* cash digest and russian doll

routes:
--------

concerns (useful while concern with complicated routes/api's call url/ polymorphic assocation routes)

instead of match route can use what type of http request it is for.

Can use constrains with help of that can specify protocol then route will generate likewise. like ftp ...

Test:
-------

where test directory is strucured differently.


******************************************************************************************************************************************************

Difference between attr_accessor and attr_accessible:

This is a very good question. I was as well very confused with all of this and I finaly undersood the point.

Many people on this thread and on google explain very well that :

1-

attr_accessor is a ruby code to (quickly) create setter and getter in a Class. That's all.

attr_accessor as a ruby method that is the combination of attr_reader and attr_writer.

attr_accessor is a ruby method that makes a getter and a setter. 

NOTE! Don’t use attr_accessor for database attributes – Rails creates those accessors for you.

attr_accessor is used when you do not have a column in your database, but still want to show a field in your forms. This field is a “virtual attribute” in a Rails model.

virtual attribute – an attribute not corresponding to a column in the database.

2-

attr_accessible specifies a whitelist of attributes that are allowed to be updated in bulk (all the attributes of an object model together at the same time) This is mainly (and only) to protect your application from "Mass assignement" pirate exploit. This is explained here on the official Rails doc : Mass Assignement.

attr_accessible is a Rails method that allows you to pass in values to a mass assignment: new(attrs) or update_attributes(attrs). 

The attr_protected method takes a list of attributes that will not be accessible for mass-assignment.

The attr_accessible method it is the exact opposite of attr_protected, because it takes a list of attributes that will be accessible. 


******************************************************************************************************************************************************

Singleton methods

Since all methods are implemented and stored by the class definition, it should be impossible for an object to define its own methods. However, Ruby provides a way around this - you can define methods that are available only for a specific object. Such methods are called Singleton Methods. 
Let us look at an example of a singleton method:

Example Code:

class Foo
end

foo=Foo.new

def foo.shout
  puts "Foo Foo Foo!"
end

foo.shout

p Foo.new.respond_to?(:shout)


## => stdout:

Foo Foo Foo!
false



******************************************************************************************************************************************************

mixins ? (multiple inherientance)

Mixins in Ruby:

Before going through this section, I assume you have knowledge of Object Oriented Concepts.

When a class can inherit features from more than one parent class, the class is supposed to show multiple inheritance.

Ruby does not support multiple inheritance directly but Ruby Modules have another wonderful use. At a stroke, they pretty much eliminate the need for multiple inheritance, providing a facility called a mixin.

Mixins give you a wonderfully controlled way of adding functionality to classes. However, their true power comes out when the code in the mixin starts to interact with code in the class that uses it.

Let us examine the following sample code to gain an understand of mixin:

module A
   def a1
   end
   def a2
   end
end
module B
   def b1
   end
   def b2
   end
end

class Sample
include A
include B
   def s1
   end
end

samp=Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1

Module A consists of the methods a1 and a2. Module B consists of the methods b1 and b2. The class Sample includes both modules A and B. The class Sample can access all four methods, namely, a1, a2, b1, and b2. Therefore, you can see that the class Sample inherits from both the modules. Thus, you can say the class Sample shows multiple inheritance or a mixin.


******************************************************************************************************************************************************

Defining a Class in Ruby:
--------------------------

To implement object-oriented programming by using Ruby, you need to first learn how to create objects and classes in Ruby.

A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals. The class Customer can be displayed as:

class Customer
end

You terminate a class by using the keyword end. All the data members in the class are between the class definition and the end keyword.
Variables in a Ruby Class:

Ruby provides four types of variables:

    Local Variables: Local variables are the variables that are defined in a method. Local variables are not available outside the method. You will see more details about method in subsequent chapter. Local variables begin with a lowercase letter or _.

    Instance Variables: Instance variables are available across methods for any particular instance or object. That means that instance variables change from object to object. Instance variables are preceded by the at sign (@) followed by the variable name.

    Class Variables: Class variables are available across different objects. A class variable belongs to the class and is a characteristic of a class. They are preceded by the sign @@ and are followed by the variable name.

    Global Variables: Class variables are not available across classes. If you want to have a single variable, which is available across classes, you need to define a global variable. The global variables are always preceded by the dollar sign ($).

******************************************************************************************************************************************************

Difference between TDD vs BDD 


To me primary difference between BDD and TDD is focus and wording. And words are important for communicating your intent.

TDD directs focus on testing. And since in "old waterfall world" tests come after implementation, then this mindset leads to wrong understanding and behaviour.

BDD directs focus on behaviour and specification, and so waterfall minds are distracted. So BDD is more easily understood as design practice and not as testing practice.

******************************************************************************************************************************************************

14 Bare Minimum Security Checks Before Releasing a Rails App

When you upload your latest app to a production Web server and open it up to the world, you're really throwing your app to the elements - good and bad. If you don't pay any attention to security whatsoever, you're likely to fall foul of some cracker's nefarious scheme and your users will be complaining when something doesn't work or they're being spammed by geriatric Nigerian clowns with pots of gold to share. But what to do?

Luckily, help is at hand in the shape of the official Ruby on Rails Security Guide, but Irish Rails developer Matthew Hutchinson has trawled through that guide as well as several illuminating blog posts relating to Rails security, and put together a 14 step checklist of "bare minimum" security checks to do before releasing your Rails app.

In summary:

-    Don't trust logged in users. (Authentication is one thing, authorization to perform certain tasks is another.)

-    Beware of mass assignments. (Use attr_accessible in your models!)

-    Make some attributes un-editable with attr_readonly.

-    Watch out for SQL injection vectors. (Raw SQL in your code is a smell worth investigating.)

-    Prevent executable files from being uploaded.

-    Filter sensitive parameters from the logs.

-    Beware CSRF (Cross-Site Request Forgery) and use protect_from_forgery and csrf_meta_tag.

-    Beware XSS (Cross-Site Scripting) and use the h helper in views (this is the default in Rails 3, luckily).

-    Watch out for session hijacks.

-    Avoid using redirects to user supplied URLs.

-    Avoid using user params or content in the send_file method.

-    Make non-ActionController methods private.

-    Check your dependencies for security updates and patches.

-    Don't store passwords in the database as clear text.

******************************************************************************************************************************************************

 Rails Security Checklist :
 ---------------------------

* Security is a dull topic, but will become exciting if you screw it up. To avoid   such excitement, here is a checklist for reviewing security in models, controllers, and views. If you see holes, add a comment and I'll update the list.

* Security checklist for models:

    * Use attr_accessible (or attr_protected if you must) to explicitly identify attributes that are accessible by .create and .update_attributes. Just because you don't expose an attribute on an edit form doesn't mean that someone won't try to post a value to it. I prefer attr_accessible over attr_protected as it fails on the side of safety when new fields are added to a model - you have to explicitly expose new fields.

    * Make sure queries are using the Rails bind variable facility for parameters, not string concatenation or the handy Ruby's #{...} syntax.
    Use validations to prevent bad input.

* Security checklist for controllers:

    * Make non-action controller methods private (if possible).
    
    * If non-action controller methods must be public, identify them with hide_action to prevent unwanted execution.
    
    * Make sure before_filters are in place if necessary for your authorization infrastructure.
    
    * Move queries from your controller to your model, and see the model checklist above.
    Check for params[:id] usage - are you sure you can trust it? Check for proper ownership of the record.

    * Check for usage of hidden fields - a user can send anything to you through them, so treat them with suspicious just as params[:id] should be suspect.
    Use filter_parameter_logging to prevent entry of sensitive unencrypted data (passwords, 
    SSN's, credit card numbers, etc.) in your server logs.

    * Forget about your view code for a minute, and think about how to protect your controller from posts a malicious user could make to any of your exposed methods. All parameters (whether or not exposed on a form, and whether or not invisible) are suspect to length overruns, bypassing of any browser based validation, attacks with malformed data, etc.

* Security checklist for views:

    Make sure all data displayed is escaped with the helper method h(string).
    Eliminate comments in your views that you don't wish the entire world to see.

What else? (In particular, considerations for REST web services and AJAX need to be added). 


******************************************************************************************************************************************************

Session vs. Cookies :
--------------------

 The main difference between cookies and sessions is that cookies are stored in the user's browser, and sessions are not. This difference determines what each is best used for.

A cookie can keep information in the user's browser until deleted. If a person has a login and password, this can be set as a cookie in their browser so they do not have to re-login to your website every time they visit. You can store almost anything in a browser cookie. The trouble is that a user can block cookies or delete them at any time. If, for example, your website's shopping cart utilized cookies, and a person had their browser set to block them, then they could not shop at your website. 

 Sessions are not reliant on the user allowing a cookie. They work instead like a token allowing access and passing information while the user has their browser open. The problem with sessions is that when you close your browser you also lose the session. So, if you had a site requiring a login, this couldn't be saved as a session like it could as a cookie, and the user would be forced to re-login every time they visit.

You can of course get the best of both worlds! Once you know what each does, you can use a combination of cookies and sessions to make your site work exactly the way you want it to. 


 * prior to Rails 4 session data was stored as a Base64 encoded Ruby object. Starting from version 4.0.0 Rails encrypts and signs this object before saving.

******************************************************************************************************************************************************

Method overriding:-
--------------------

Method overriding, in object oriented programming, is a language feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its superclasses. The implementation in the subclass overrides (replaces) the implementation in the superclass.



class A  
  def a  
    puts 'In class A'  
  end  
end  
  
class B < A  
  def a  
    puts 'In class B'  
  end  
end  
  
b = B.new  
b.a 

Usage of super :-
--------------

The way super handles arguments is as follows:

    When you invoke super with no arguments Ruby sends a message to the parent of the current object, asking it to invoke a method of the same name as the method invoking super. It automatically forwards the arguments that were passed to the method from which it's called.
    Called with an empty argument list - super()-it sends no arguments to the higher-up method, even if arguments were passed to the current method.
    Called with specific arguments - super(a, b, c) - it sends exactly those arguments.



    class Bicycle  
      attr_reader :gears, :wheels, :seats  
      def initialize(gears = 1)  
        @wheels = 2  
        @seats = 1  
        @gears = gears  
      end  
    end  
      
    class Tandem < Bicycle  
      def initialize(gears)  
        super  
        @seats = 2  
      end  
    end  
    t = Tandem.new(2)  
    puts t.gears  
    puts t.wheels  
    puts t.seats  
    b = Bicycle.new  
    puts b.gears  
    puts b.wheels  
    puts b.seats  

******************************************************************************************************************************************************

Ruby Overloading Methods:
-----------------------------

You want to create two different versions of a method with the same name: two methods that differ in the arguments they take.

Constructor overloading:
-----------------------------
Constructor overloading is the ability to have multiple types of constructors in a class. This way we can create an object with different number or different types of parameters.

Ruby has no constructor overloading that we know from some programming languages. This behaviour can be simulated to some extent with default parameter values in Ruby.

#!/usr/bin/ruby


class Person

    def initialize name="unknown", age=0
        @name = name
        @age = age        
    end
    
    def to_s
        "Name: #{@name}, Age: #{@age}"
    end

end

p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4

This example shows how we could simulate constructor overloading on a Person class that has two member fields. When the name parameter is not specified, the string "unknown" is used instead. For unspecified age we have 0.

def initialize name="unknown", age=0
    @name = name
    @age = age        
end

The constructor takes two parameters. They have a default value. The default value is used if we do not specify our own values at the object creation. Note that the order of parameters must be kept. First comes the name, then the age.

p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4

We create four objects. The constructors take different number of parameters.

$ ./consover.rb
Name: unknown, Age: 0
Name: unknown, Age: 17
Name: Becky, Age: 19
Name: Robert, Age: 0

This is the output of the example. 

******************************************************************************************************************************************************

Differences between private, public, and protected methods:
-----------------------------------------------------------

Put simply, the differences between private, public, and protected methods are visibility of that method in the program, kinda like read-only, read and write, and near invisible.

Unlike some of the other languages, you can't completely hide a Ruby private method, you can only access private methods for your instance of object and not for any other object instance of a class.

Public, of course, is total accessibility and methods are usually defaulted to public with some exceptions.

Protected methods are accessible from objects of the same class or even children, which is not the case for a private method.

/-----------------------------------------------/

* Ruby gives you three levels of protection:

    Public methods can be called by everyone - no access control is enforced. A class's instance methods (these do not belong only to one object; instead, every instance of the class can call them) are public by default; anyone can call them. The initialize method is always private.
    
    Protected methods can be invoked only by objects of the defining class and its subclasses. Access is kept within the family. However, usage of protected is limited.
    
    Private methods cannot be called with an explicit receiver - the receiver is always self. This means that private methods can be called only in the context of the current object; you cannot invoke another object's private methods.



******************************************************************************************************************************************************

bang method ? diff. [ save and save! ] .


save will return false if the record can't be saved (validation errors for instance).

save! will raise an exception if the record can't be saved. Use save! when you are pretty dang sure it should save with no problem, and if it doesn't then its a pretty huge bug and an exception is appropriate.


It's "just sugarcoating" for readability, but they do have common meanings:

    Methods ending in ! perform some permanent or potentially dangerous change; for example:
        Enumerable#sort returns a sorted version of the object while Enumerable#sort! sorts it in place.
        In Rails, ActiveRecord::Base#save returns false if saving failed, while ActiveRecord::Base#save! raises an exception.
        Kernel::exit causes a script to exit, while Kernel::exit! does so immediately, bypassing any exit handlers.
    Methods ending in ? return a boolean, which makes the code flow even more intuitively like a sentence — if number.zero? reads like "if the number is zero", but if number.zero just looks weird.

In your example, name.reverse evaluates to a reversed string, but only after the name.reverse! line does the name variable actually contain the reversed name. name.is_binary_data? looks like "is name binary data?".

******************************************************************************************************************************************************

Difference between delete and destroy ?

Basically destroy runs any callbacks on the model while delete doesn't.


Difference between delete and destroy in ActiveRecord

This is well documented, but I keep running into the same issue and never learn from my mistakes. ;-)

When you invoke 'destroy' or 'destroy_all' on an ActiveRecord object, the ActiveRecord 'destruction' process is initiated, it analyzes the class you're deleting, it determines what it should do for dependencies, runs through validations, etc.

When you invoke 'delete' or 'delete_all' on an object, ActiveRecord merely tries to run the 'DELETE FROM tablename WHERE conditions' query against the db, performing no other ActiveRecord-level tasks.

This also holds true for the :dependent option passed into the ActiveRecord::Association methods (belongs_to, has_one, has_many, has_and_belongs_to_many)

Thus if you have a circular dependency between two model classes, and you want to delete both related records when one is deleted, one of the :dependent clauses _must_ be :destroy and the other :delete. if both are set to :destroy you'll have an infinite loop resulting in a "SystemStackError: stack level too deep" exception.

For example

class Person < ActiveRecord::Base
has_one :address, :dependent => :destroy
validate_presence_of :address
end

class Address < ActiveRecord::Base
belongs_to :person, :dependent => :delete
validates_presence_of :person
end

With this scenario, you are free to add a foreign key constraint to the person_id field of the addresses table and everything will still behave as expected. Best of luck.


******************************************************************************************************************************************************

pluck is on the db level. It will only query the particular field. See this.

When you do:

 User.first.gifts.collect(&:id)

You have objects with all fields loaded and you simply get the id thanks to the method based on Enumerable.

So:

    if you only need the id, use pluck

    if you need all fields, use collect

    if you need some fields, use selectand collect

******************************************************************************************************************************************************

ORM ? why ORM ? If not there how things are done ?


Object Relational Mapping

Object-Relational Mapping, commonly referred to as its abbreviation ORM, is a technique that connects the rich objects of an application to tables in a relational database management system. Using ORM, the properties and relationships of the objects in an application can be easily stored and retrieved from a database without writing SQL statements directly and with less overall database access code.
1.3 Active Record as an ORM Framework

Active Record gives us several mechanisms, the most important being the ability to:

    * Represent models and their data.
    * Represent associations between these models.
    * Represent inheritance hierarchies through related models.
    * Validate models before they get persisted to the database.
    * Perform database operations in an object-oriented fashion.

******************************************************************************************************************************************************

rake ?

Rake is a utility similar to make in Unix. You can say Rake is the make of ruby - the R uby m AKE. Rails defines a number of tasks to help you.

rake db:migrate,rake db:create,rake db:reset,rake db:seed

Rake is Ruby Make, a standalone Ruby utility that replaces the Unix utility 'make', and uses a 'Rakefile' and .rake files to build up a list of tasks.

** Rake utility allows you to create a job/task which uses rails environment.

******************************************************************************************************************************************************

Advantages of "migrations" in rails ?

Rails Migration allows you to use Ruby to define changes to your database schema, making it possible to use a version control system to keep things synchronized with the actual code.

This has many uses, including:

    Teams of developers - if one person makes a schema change, the other developers just need to update, and run "rake migrate".

    Production servers - run "rake migrate" when you roll out a new release to bring the database up to date as well.

    Multiple machines - if you develop on both a desktop and a laptop, or in more than one location, migrations can help you keep them all synchronized.

******************************************************************************************************************************************************

* Difference between git pull vs git rebase ?

git pull = git fetch + git merge against tracking upstream branch.

git pull --rebase = git fetch + git rebase against tracking upstream branch.


Git Pull:
------------

From what I understand, git pull will pull down from a remote whatever you ask (so, whatever trunk you’re asking for) and instantly merge it into the branch you’re in when you make the request. Pull is a high-level request that runs ‘fetch’ then a ‘merge’ by default, or a rebase with ‘–rebase’. You could do without it, it’s just a convenience.
    
    git checkout localBranch
    git pull origin master
    git branch
    master
    * localBranch

The above will merge the remote “master” branch into the local “localBranch”.


Git rebase:
-------------

Finally, git rebase is pretty cool. Anything you’ve changed by committing to your current branch but are no in the upstream are saved to a temporary area, so your branch is the same as it was before you started your changes, IE, clean. If you do ‘git pull –rebase’, git will pull down the remote changes, rewind your local branch, then replays all your changes over the top of your current branch one by one, until you’re all up to date. Awesome huh?

******************************************************************************************************************************************************

What is git merge?
-------------------

Once you’ve finished developing a feature in an isolated branch, it's important to be able to get it back into the main code base. Depending on the structure of your repository, Git has several distinct algorithms to accomplish this: a fast-forward merge or a 3-way merge.


e.g. git branch 
    ---> development

    & your development branch is forward than master
    and you want to make same at same level then 

    git checkout master

    git status

    if any pending/unstaged ... commit and push that one.

    git fetch  --> (will take download all untraked branches new one which were not at local)

    git rebase origin/development  (This is nothing but merging development branch code with master.)

******************************************************************************************************************************************************

git fork
--------- 

people fork repositories when they want to make a change the code, because you don't have write access to the original repository

In the forked repository they have write access and can push changes. They may even contribute back to the original repository using pull requests.


Process of it:
--------------

In order to make a pull request you need to do the following steps:

    Fork a repository (to which you want to make a pull request). Just click the fork button the the repository page and you will have a separate github repository preceded with your github username.
    Clone the repository to your local machine. The Github software that you installed on your local machine can do this for you. Click the clone button beside the repository name.
    Make local changes/commits to the files
    sync the changes
    go to your github forked repository and click the "Compare & Review" green button besides the branch button. (The button has icon - no text)
    A new page will open showing your changes and then click the pull request link, that will send the request to the original owner of the repository you forked.

It took me a while to figure this, hope this will help someone.

******************************************************************************************************************************************************


What is AJAX ?

Ajax (Asynchronous JavaScript and XML) is a method of building interactive applications for the Web that process user requests immediately. Ajax combines several programming tools including JavaScript, dynamic HTML (DHTML), Extensible Markup Language (XML), cascading style sheets (CSS), the Document Object Model (DOM), and the Microsoft object, XMLHttpRequest. 

Ajax allows content on Web pages to update immediately when a user performs an action, unlike an HTTP request, during which users must wait for a whole new page to load

e.g. Google Maps is one well-known application that uses Ajax. The interface allows the user to change views and manipulate the map in real time. 

Ajax applications do not require installation of a plug-in, but work directly with a Web browser. Because of the technique's reliance on 

How it works ?

Applications created with Ajax use an engine that acts as an intermediary between a user's browser and the server from which it is requesting information. Instead of loading a traditional Web page, the user's browser loads the Ajax engine, which displays the page the user sees. The engine continues to run in the background, using JavaScript to communicate with the Web browser. User input or clicking on the page sends a JavaScript call to the Ajax engine, which can respond instantly in many cases. If the engine needs additional data, it requests it from the server, usually using XML, while it is simultaneously updating the page.



******************************************************************************************************************************************************


MyISAM vs Innodb - Quick comparison Table:

MyISAM  Innodb

Not *ACID compliant and non-transactional        |       *ACID compliant and       hence fully transactional with ROLLBACK and COMMIT and support for Foreign Keys

MySQL 5.0 Default Engine                          |  Rackspace Cloud Default Engine

Offers Compression                                 | Offers Compression

Requires full repair/rebuild of indexes/tables     |     Auto recovery from crash   via replay of logs

Changed Db pages written to disk instantly  Dirty pages converted from random to 

sequential before commit and flush to disk

No ordering in storage of data  Row data stored in pages in PK order

Table level locking     Row level locking


******************************************************************************************************************************************************

Method overloading - 
----------------------

Method overloading can be achieved by declaring two methods with the same name and different signatures. These different signatures can be either,
    Arguments with different data types, eg: method(int a, int b) vs method(String a, String b)
    Variable number of arguments, eg: method(a) vs method(a, b)

We cannot achieve method overloading using the first way because there is no data type declaration in ruby(dynamic typed language). So the only way to define the above method is def(a,b)

With the second option, it might look like we can achieve method overloading, but we can't. Let say I have two methods with different number of arguments,

def method(a); end;
def method(a, b = true); end; # second argument has a default value

method(10)
# Now the method call can match the first one as well as the second one, 
# so here is the problem.

So ruby needs to maintain one method in the method look up chain with a unique name.

How to atchive it :
---------------------

*** Ruby has four tricks to mimic method overloading, and I am going to bundle the first two together. The first is default values in the method definition. Simply give a parameter a default value and it becomes optional.

******************************************************************************************************************************************************

bundle update and 

bundle install can all install the gems you specified in Gemfile but missing in gems.

But bundle update does one thing more to upgrade:

    If the gems specified in Gemfile don't have version, it will upgrade to whatever latest.

    If the gems specified in Gemfile have version controlled with ~>, it will upgrade to the latest at the final digit, the patch version.

    For example, if you have a gem in Gemfile

    'foo_gem', '~> 2.1.0'

    bundle update will check if newer version of 2.1.x is available in cloud. Say your current version is 2.1.2 and what's latest in cloud is 2.1.5, it will install 2.1.5. But if 2.2.6 is the newest, it won't do anything.

Better practice in my opinion

    Always add version to critical gems like rails.

    Stick to bundle install(or bundle which is default to install) in most cases. Only do bundle update when it's really necessary and you are fully prepared for the result.

******************************************************************************************************************************************************


This operator matches strings against regular expressions.

1.9.3-p194 :001 > m1 = /Ruby/.match("The future is Ruby")
 => #<MatchData "Ruby"> 
1.9.3-p194 :002 > m2 = "The future is Ruby" =~ /Ruby/  
 => 14 
1.9.3-p194 :003 > 


.match O/P #=> 

If there's no match, you get back nil. If there's a match, it returns an instance of the class MatchData.

=~ O/P #=> 

If the String matches the expression, the operator returns the offset, and if it doesn't, it returns nil.

******************************************************************************************************************************************************

Array without iterating compare ==> count with condition

1.9.3-p194 :003 > ary = [1, 2, 4, 2]
 => [1, 2, 4, 2] 
1.9.3-p194 :004 > ary.count(2)  
 => 2 
1.9.3-p194 :005 > ary.count(4)  
 => 1 

******************************************************************************************************************************************************

Dynamic language:-

dynamic language, you can create methods on the fly, add instance variables, define constants and invoke existing methods dynamically 


******************************************************************************************************************************************************

Metaprogramming : -Any code that significantly raises the level of abstraction and/or any code that creates code. 

Metaprogramming is what makes Ruby awesome. It’s writing code to write code. It’s dynamic code generation. 


Java - Unfortunately Java does not readily support class creation at runtime (mitaprograming not support).

******************************************************************************************************************************************************

Some of the highlights: Ruby 2.0.0-p0  :- 
---------------------------------------

    Language core features
        Keyword arguments, which give flexibility to API design
        Module#prepend, which is a new way to extend a class
        A literal %i, which creates an array of symbols easily
        __dir__, which returns the dirname of the file currently being executed
        The UTF-8 default encoding, which make many magic comments omissible
    Built-in libraries
        Enumerable#lazy and Enumerator::Lazy, for (possibly infinite) lazy stream
        Enumerator#size and Range#size, for lazy size evaluation
        #to_h, which is a new convention for conversion to Hash
        Onigmo, which is a new regexp engine (a fork of Oniguruma)
        Asynchronous exception handling API
    Debug support
        DTrace support, which enables run-time diagnosis in production
        TracePoint, which is an improved tracing API
    Performance improvements
        GC optimization by bitmap marking
        Kernel#require optimization which makes Rails startup very fast
        VM optimization such as method dispatch
        Float operation optimization

******************************************************************************************************************************************************


e.g. 

send
dynamic_finders
define_method
define_singleton_method
alias_method
instance_eval
class_eval
module_eval
const_get
const_defined?
const_set


******************************************************************************************************************************************************

** Metaprogramming Ruby, an in-depth guide to dynamic code and code generation in Ruby. 

 class_eval and instance_eval -  These methods allow you to evaluate arbitrary code in the context of a particular class or object. 

 They're slightly similar to  'call', 'apply' and 'bind' in JavaScript, in that you are altering the value of self (this in JavaScript) when you use them. 


    * "Most notably classes and methods - can be changed at runtime .."

    * methods to a class can be added removed or redefined ...




class Person
end

Person.class_eval do
  def say_hello
   "Hello!"
  end
end

jimmy = Person.new
jimmy.say_hello # "Hello!"


In this example, class_eval allows us to define a method within the Person class outside of its original definition and without reopening the class with the standard syntax. This could be useful when the class you want to add this method to is not known until runtime.



class Person
end

Person.instance_eval do
  def human?
    true
  end
end

Person.human? # true

This example of instance_eval is similar, but evaluates the code in the context of an instance instead of a class. This is confusing at first, because in these examples class_eval creates instance methods and instance_eval creates class methods. There is reason behind the madness, however.

** class_eval is a method of the Module class, meaning that the receiver will be a module or a class. The block you pass to class_eval is evaluated in the context of that class.

** instance_eval, on the other hand, is a method of the Object class, meaning that the receiver will be an object. The block you pass to instance_eval is evaluated in the context of that object.



******************************************************************************************************************************************************

send method :

Ruby gives you convinient way for you to call any method on an object using send method.

Send takes, as it's first argument the name of the method that you want to call.
This name can either a symbol or string.

******************************************************************************************************************************************************

Ruby/rails performance tools :-

*** The "bullet gem" is a great starting point to find N+1 queries, unecessary eager  loading and opportunity to use counter cache.

*** But what if it’s not something that bullet can pickup? Well I personally like "rack-mini-profiler". MiniProfiler will profile your code and report it in a very nice way right on your page.

*** You can also go further down the hole and use the "ruby-prof gem". If it’s the case where your bottleneck is not the database or if you’re not on a rack application where you can use the MiniProfiler.




******************************************************************************************************************************************************

Q - Preload, Eagerload, Includes and Joins. 

Preload loads the association data in a separate query. 

User.preload(:posts).to_a

# =>
SELECT "users".* FROM "users"
SELECT "posts".* FROM "posts"  WHERE "posts"."user_id" IN (1)

This is how includes loads data in the default case.

Since preload always generates two sql we can't use posts table in where condition. Following query will result in an error.


User.preload(:posts).where("posts.desc='ruby is awesome'")

# =>
SQLite3::SQLException: no such column: posts.desc: 
SELECT "users".* FROM "users"  WHERE (posts.desc='ruby is awesome')


----------------------------------------------------------------------------------
Includes :

*Q* User.includes(:posts).where('posts.desc = "ruby is awesome"').to_a

# =>
SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, "posts"."id" AS t1_r0, 
       "posts"."title" AS t1_r1, 
       "posts"."user_id" AS t1_r2, "posts"."desc" AS t1_r3 
FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id" 
WHERE (posts.desc = "ruby is awesome")

 As you can see includes switches from using two separate queries to creating a single LEFT OUTER JOIN to get the data. And it also applied the supplied condition.

----------------------------------------------------------------------------------

Eager loading loads all association in a single query using LEFT OUTER JOIN.

User.eager_load(:posts).to_a

# =>
SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, "posts"."id" AS t1_r0, 
       "posts"."title" AS t1_r1, "posts"."user_id" AS t1_r2, "posts"."desc" AS t1_r3 
FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"


----------------------------------------------------------------------------------

Joins brings association data using inner join. 

User.joins(:posts)

# =>
SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id"


In the above case no posts data is selected. Above query can also produce duplicate result. To see it let's create some sample data.

def self.setup
  User.delete_all
  Post.delete_all

  u = User.create name: 'Neeraj'
  u.posts.create! title: 'ruby', desc: 'ruby is awesome'
  u.posts.create! title: 'rails', desc: 'rails is awesome'
  u.posts.create! title: 'JavaScript', desc: 'JavaScript is awesome'

  u = User.create name: 'Neil'
  u.posts.create! title: 'JavaScript', desc: 'Javascript is awesome'

  u = User.create name: 'Trisha'
end

With the above sample data if we execute User.joins(:posts) then this is the result we get

#<User id: 9, name: "Neeraj">
#<User id: 9, name: "Neeraj">
#<User id: 9, name: "Neeraj">
#<User id: 10, name: "Neil">

We can avoid the duplication by using distinct .

User.joins(:posts).select('distinct users.*').to_a

Also if we want to make use of attributes from posts table then we need to select them.

records = User.joins(:posts).select('distinct users.*, posts.title as posts_title').to_a
records.each do |user|
  puts user.name
  puts user.posts_title
end

Note that using joins means if you use user.posts then another query will be performed.

******************************************************************************************************************************************************


jQuery differences between the bind and live functions:
----------------------------------------------------------

In short: .bind() will only apply to the items you currently have selected in your jQuery object. .live() will apply to all current matching elements, as well as any you might add in the future.

The underlying difference between them is that live() makes use of event bubbling. That is, when you click on a button, that button might exist in a <p>, in a <div>, in a <body> element; so in effect, you're actually clicking on all of those elements at the same time.

live() works by attaching your event handler to the document, not to the element. When you click on that button, as illustrated before, the document receives the same click event. It then looks back up the line of elements targeted by the event and checks to see if any of them match your query.

The outcome of this is twofold: firstly, it means that you don't have to continue reapplying events to new elements, since they'll be implicitly added when the event happens. However, more importantly (depending on your situation), it means that your code is much much lighter! If you have 50 <img> tags on the page and you run this code:

$('img').click(function() { /* doSomething */ });

...then that function is copied into each of those elements. However, if you had this code:

$('img').live('click', function() { /* doSomething */ });

...then that function is stored only in one place (on the document), and is applied to whatever matches your query at event time.

Because of this bubbling behaviour though, not all events can be handled this way. As Ichiban noted, these supported events are click, dblclick mousedown, mouseup, mousemove, mouseover, mouseout, keydown, keypress, keyup.

******************************************************************************************************************************************************
method_missing :
------------------


http://code.tutsplus.com/tutorials/ruby-for-newbies-missing-methods--net-20924

Let’s say your working with a Ruby object. And let’s also say that you aren’t entirely familiar with this object. And let’s also say that you call a method that doesn’t exist on the object.
    
o = <span class="skimlinks-unlinked">Object.new</span>
o.some_method
# NoMethodError: undefined method `some_method' for #<Object:0x00000100939828>

This is less than desirable, so Ruby has an awesome way of allowing us to rescue ourselves from this. Check this out:

    
class OurClass
  def method_missing (method_name)
    puts "there's no method called '#{method_name}'"
  end
end
 
o = <span class="skimlinks-unlinked">OurClass.new</span>
o.some_method
# => there's no method called 'some_method'

We can create a method called method_missing in our class. If the object we’re calling the method on doesn’t have the method (and doesn’t inherit the method from another class or module), Ruby will give us one more chance to do something useful: if the class has a method_missing method, we’ll hand the information about the method cal to method_missing and let it sort the mess out.

Well, that’s great; we’re no longer getting an error message.

******************************************************************************************************************************************************

Ruby Module vs Class :
-----------------------

Ruby modules allow you to create groups of methods that you can then include or mix into any number of classes. Modules only hold behaviour, unlike classes, which hold both behaviour and state.

Since a module cannot be instantiated, there is no way for its methods to be called directly. Instead, it should be included in another class, which makes its methods available for use in instances of that class.

******************************************************************************************************************************************************


Active Resource :-

Chirag:

    1. i18n -> 2 methods ?

    2. how to use i18n in javascript ?

    3. Active Relation ? lazy loading ? (Arel ..)

    4. Rails Cashing ?

    5. what comes in application controller ?

    6. date format with the help of i18n ?

    7. multi Tenant Architechture

    8. different log levels  --> debug, info , warning, error.
        e.g. 
    * during development of application [ development ] <---> debug log 
    
    * E-commerce site suppose we have keeping information about daily transaction count         <--->  info log

    * product stock has been reducing so keep product in stock <---> warning log

    * error occurs like user has provided wrong url so got page break <---> error log

    9. 


 Ray B -
 --------   


  Method_missing ?
 
  What is REST ?

  Test framworks famiilier of ?

  Rails Engie ?

  Different associations in rails ?

  Seachange / adrenline ?

  How to debug a rails application ?

  Sintra framwork ?

  Where used metaprogramming ?

  Outer Joins ?


  








rack ?

Observer in rails ? (are they still in rails 4) ?

static method ?

strong parameters ?

gem vs plugin --> in rails can we keep plugins ?

metaprogramming in ruby ? where we use ?

what contains in rubygems?

difference between has_one and belongs_to ?

class and modules difference ?

ruby object oriented ?

string symbols in ruby ?

hases in ruby and actionsupport how it differs ?

getter / setter methods in ruby ?

abstraction in ruby ?

object-overriding and object overwritting in ruby ?

csrf - cross site request forgery rails ?

test framworks in ruby ?

xhr requests in rails ?

xss and csrf ?

get post request in http protocol difference ?

TDD / BDD ?
    
mysql vs mongodb ? 

singleton object / class 

design patterns ?



while dealing with 3rd party API's what security concerns do we need to keep in mind ?

"Transfering from http --> https" ?








