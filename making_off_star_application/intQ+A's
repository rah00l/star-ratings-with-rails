* Compairesion of Postgreql and Mysql
-----------------------------------------------------------------------------------------------
			Postgreql			Mysql	
-----------------------------------------------------------------------------------------------
ANSI SQL compliance 	Closer to ANSI SQL standard 	Follows some of the ANSI SQL standards
Performance 		Slower 				Faster
Sub-selects 		Yes 				No
Transactions 		Yes 				Yes, however InnoDB table type must be used
Database replication 	Yes 				Yes
Foreign key support 	Yes 				No
Views 			Yes 				No
Stored procedures 	Yes 				No
Triggers 		Yes 				No
Unions 			Yes 				No
Full joins 		Yes 				No
Constraints 		Yes 				No
Windows support 	Yes 				Yes
Vacuum (cleanup) 	Yes 				No
ODBC 			Yes 				Yes
JDBC 			Yes 				Yes
Different table types 	No 				Yes


When to use MySQL:-
Why would you use MySQL over PostgreSQL? First, we need to consider the needs of the applications in terms of database requirements. If I want to create a Web application and performance is an issue, MySQL will be my choice because it’s fast and designed to work well with Web-based servers. However, if I want to create another application that demands transactions and foreign key references, PostgreSQL is the choice.


Let me suggest some reasons for using MySQL over PostgreSQL:

    MySQL is relatively faster than PostgreSQL.
    Database design will be simpler.
    You can create a basic Web-driven Web site.
    MySQL’s replication has been thoroughly tested.
    There’s no need for cleanups in MySQL (Vacuum).


When to use PostgreSQL:-
Not many Web developers use PostgreSQL because they feel that the additional features degrade performance.

For example, some of the features I use are foreign key references, triggers, and views. They allow me to hide the complexity of the database from the application, thus avoiding the creation of complicated SQL commands. I know many developers who prefer the rich functionality of PostgreSQL’s SQL commands. One of the most notable differences between MySQL and PostgreSQL is the fact that you can’t do nested subqueries of subselects in MySQL. PostgreSQL follows many of the SQL ANSI standards, thus allowing the creation of complex SQL commands.



Let me suggest some reasons for using PostgreSQL over MySQL:

    Complex database design
    Moving away from Oracle, Sybase, or MSSQL
    Complex rule sets (i.e., business rules)
    Use of procedural languages on the server
    Transactions
    Use of stored procedures
    Use of geographical data
    R-Trees (i.e., used on indexes)



 Difference between HTTP and HTTPS: HTTPS = HTTP + SSL

1. URL begins with “http://" in case of HTTP while the URL begins with “https://” in case of HTTPS.
2. HTTP is unsecured while HTTPS is secured.
3. HTTP uses port 80 for communication while HTTPS uses port 443 for communication.
4. HTTP operates at Application Layer while HTTPS operates at Transport Layer.
5. No encryption is there in HTTP while HTTPS uses encryption.
6. No certificates required in HTTP while certificates required in HTTPS.

How HTTPS works?
For HTTPS connection, public key and signed certificates are required for the server. 
 When using an https connection, the server responds to the initial connection by offering a list of encryption methods it supports. In response, the client selects a connection method, and the client and server exchange certificates to authenticate their identities. After this is done, both parties exchange the encrypted information after ensuring that both are using the same key, and the connection is closed. In order to host https connections, a server must have a public key certificate, which embeds key information with a verification of the key owner's identity. Most certificates are verified by a third party so that clients are assured that the key is secure.
In other words, we can say, HTTPS works similar to HTTP but SSL adds some spice in it.



************************************************************************

Simple Object Access Protocol (SOAP) and REpresentational State Transfer (REST) :-
    SOAP and REST are protocols: a set of rules for requesting information from a server using a specific technique.




SOAP: -
    * Originally developed by Microsoft, SOAP really isn’t as simple as the acronym would suggest.
    * SOAP relies exclusively on XML to provide messaging services. 
    * Microsoft originally developed SOAP to take the place of older technologies that don’t work well on the Internet such as the Distributed Component          Object Model (DCOM) and Common Object Request Broker Architecture (CORBA). These technologies fail because they rely on binary messaging; the XML           messaging that SOAP employs works better over the Internet.
    * The XML used to make requests and receive responses in SOAP can become extremely complex. In some programming languages, you need to build those         requests manually, which becomes problematic because SOAP is intolerant of errors.
    * Part of the magic is the Web Services Description Language (WSDL). This is another file that’s associated with SOAP. It provides a definition of          how the Web service works, so that when you create a reference to it, the IDE can completely automate the process.
    * One of the most important SOAP features is built-in error handling. If there’s a problem with your request, the response contains error information           that you can use to fix the problem.




REST:-
    * REST is the newcomer to the block. It seeks to fix the problems with SOAP and provide a truly simple method of accessing Web services.
    * Many developers found SOAP cumbersome and hard to use. For example, working with SOAP in JavaScript means writing a ton of code to perform            extremely simple tasks because you must create the required XML structure absolutely every time.
    * REST provides a lighter weight alternative.
    * Instead of using XML to make a request, REST relies on a simple URL in many cases.
    * REST can use four different HTTP 1.1 verbs (GET, POST, PUT, and DELETE) to perform tasks.
    * Unlike SOAP, REST doesn’t have to use XML to provide the response. You can find REST-based Web services that output the data in Command Separated             Value (CSV), JavaScript Object Notation (JSON) and Really Simple Syndication (RSS). The point is that you can obtain the output you need in a           form that’s easy to parse within the language you need for your application.

SOAP is definitely the heavyweight choice for Web service access. It provides the following advantages when compared to REST:

    Language, platform, and transport independent (REST requires use of HTTP)
    Works well in distributed enterprise environments (REST assumes direct point-to-point communication)
    Standardized
    Provides significant pre-build extensibility in the form of the WS* standards
    Built-in error handling
    Automation when used with certain language products

REST is easier to use for the most part and is more flexible. It has the following advantages when compared to SOAP:

    No expensive tools require to interact with the Web service
    Smaller learning curve
    Efficient (SOAP uses XML for all messages, REST can use smaller message formats)
    Fast (no extensive processing required)
    Closer to other Web technologies in design philosophy.

******************************************************************************************************************************************************
Web Server and Application server:-

Most of the times these terms Web Server and Application server are used interchangeably.

Following are some of the key differences in features of Web Server and Application Server:

    Web Server is designed to serve HTTP Content. App Server can also serve HTTP Content but is not limited to just HTTP. It can be provided other protocol support such as RMI/RPC
    Web Server is mostly designed to serve static content, though most Web Servers have plugins to support scripting languages like Perl, PHP, ASP, JSP etc. through which these servers can generate dynamic HTTP content.
    Most of the application servers have Web Server as integral part of them, that means App Server can do whatever Web Server is capable of. Additionally App Server have components and features to support Application level services such as Connection Pooling, Object Pooling, Transaction Support, Messaging services etc.
    As web servers are well suited for static content and app servers for dynamic content, most of the production environments have web server acting as reverse proxy to app server. That means while servicing a page request, static contents (such as images/Static HTML) are served by web server that interprets the request. Using some kind of filtering technique (mostly extension of requested resource) web server identifies dynamic content request and transparently forwards to app server

Example of such configuration is Apache Tomcat HTTP Server and Oracle (formerly BEA) WebLogic Server. Apache Tomcat HTTP Server is Web Server and Oracle WebLogic is Application Server.

In some cases the servers are tightly integrated such as IIS and .NET Runtime. IIS is web server. When equipped with .NET runtime environment, IIS is capable of providing application services.

******************************************************************************************************************************************************


Differences between Procs and Lambdas: 
    * It is important to mention that they are both Proc objects.
        proc = Proc.new { puts "Hello world" }
        lam = lambda { puts "Hello World" }
        
        proc.class # returns 'Proc'
        lam.class

    ** Lambdas check the number of arguments, while procs do not

    1 lam = lambda { |x| puts x }    # creates a lambda that takes 1 argument
    2 lam.call(2)                    # prints out 2
    3 lam.call                       # ArgumentError: wrong number of arguments (0 for 1)
    4. lam.call(1,2,3)                # ArgumentError: wrong number of arguments (3 for 1)

    In contrast, procs don’t care if they are passed the wrong number of arguments.

    1 proc = Proc.new { |x| puts x } # creates a proc that takes 1 argument
    2 proc.call(2)                   # prints out 2
    3 proc.call                      # returns nil
    4 proc.call(1,2,3)               # prints out 1 and forgets about the extra arguments
    
    As shown above, procs don’t freak out and raise errors if they are passed the wrong number of arguments. If the proc requires an argument but no    argument is passed then the proc returns nil. If too many arguments are passed than it ignores the extra arguments. 

    ** Lambdas and procs treat the ‘return’ keyword differently 
       ‘return’ inside of a lambda triggers the code right outside of the lambda code 
        
        def lambda_test
          lam = lambda { return }
          lam.call
          puts "Hello world"
        end

        lambda_test                 # calling lambda_test prints 'Hello World'

       ‘return’ inside of a proc triggers the code outside of the method where the proc is being executed 

        def proc_test
          proc = Proc.new { return }
          proc.call
          puts "Hello world"
        end

        proc_test                 # calling proc_test prints nothing


******************************************************************************************************************************************************

The Asset Pipeline :-

    *** The first feature of the pipeline is to concatenate assets, which can reduce the number of requests that a browser makes to render a web page.          Web browsers are limited in the number of requests that they can make in parallel, so fewer requests can mean faster loading for your application.
        Sprockets concatenates all JavaScript files into one master .js file and all CSS files into one master .css file. 

    *** The second feature of the asset pipeline is asset minification or compression. For CSS files, this is done by removing whitespace and comments.             For JavaScript, more complex processes can be applied. You can choose from a set of built in options or specify your own.

    *** The third feature of the asset pipeline is it allows coding assets via a higher-level language, with precompilation down to the actual assets.          Supported languages include Sass for CSS, CoffeeScript for JavaScript, and ERB for both by default.


******************************************************************************************************************************************************
Ruby Keyword super :- 

A common use of inheritance is to have overridden methods in a subclass do something in addition to what the superclass method did, rather than something entirely different (like in previous examples). This allows us to re-use behaviour that exists in a superclass, then modify to suit the needs of the subclass.

Most object oriented languages offer a mechanism by which an overridden method can be called by the overriding method. Ruby uses the super keyword to make this happen. Using super will call the same method, but as defined in the superclass and give you the result.


class Animal
  def move
    "I can move"
  end
  def eat 
    "Can eat small fishes..!"
  end
end

class Bird < Animal
  def move
    super + " by flying"
  end
  def eat 
    super + "can eat big fishes..!"
  end
end

puts Animal.new.move
puts Bird.new.move
puts Bird.new.eat    

O/P =>

 stdout:

I can move
I can move by flying
Can eat small fishes..!can eat big fishes..!

******************************************************************************************************************************************************


jQuery differences between the bind and live functions:

In short: .bind() will only apply to the items you currently have selected in your jQuery object. .live() will apply to all current matching elements, as well as any you might add in the future.

The underlying difference between them is that live() makes use of event bubbling. That is, when you click on a button, that button might exist in a <p>, in a <div>, in a <body> element; so in effect, you're actually clicking on all of those elements at the same time.

live() works by attaching your event handler to the document, not to the element. When you click on that button, as illustrated before, the document receives the same click event. It then looks back up the line of elements targeted by the event and checks to see if any of them match your query.

The outcome of this is twofold: firstly, it means that you don't have to continue reapplying events to new elements, since they'll be implicitly added when the event happens. However, more importantly (depending on your situation), it means that your code is much much lighter! If you have 50 <img> tags on the page and you run this code:

$('img').click(function() { /* doSomething */ });

...then that function is copied into each of those elements. However, if you had this code:

$('img').live('click', function() { /* doSomething */ });

...then that function is stored only in one place (on the document), and is applied to whatever matches your query at event time.

Because of this bubbling behaviour though, not all events can be handled this way. As Ichiban noted, these supported events are click, dblclick mousedown, mouseup, mousemove, mouseover, mouseout, keydown, keypress, keyup.

******************************************************************************************************************************************************

Q- difference between collection routes and member routes in Rails

A member route will require an ID, because it acts on a member. A collection route doesn't because it acts on a collection of objects. Preview is an example of a member route, because it acts on (and displays) a single object. Search is an example of a collection route, because it acts on (and displays) a collection of objects.

******************************************************************************************************************************************************
